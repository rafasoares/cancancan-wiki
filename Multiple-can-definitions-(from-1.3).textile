h2. Multiple @can@ definitions

It is now possible to specify multiple @can@ and @cannot@ definitions with hashes and have it properly translate to a single SQL query.

<pre>
# in Ability
can :manage, User, :id => 1
can :manage, User, :manager_id => 1
cannot :manage, User, :self_managed => true
</pre>

When using @accessible_by@ in the controller it will translate to SQL conditions that look like this.

<pre>
not (self_managed = 't') AND ((manager_id = 1) OR (id = 1))
</pre>

Special thanks to "funny-falcon":http://github.com/funny-falcon for this feature.

Also this change introduced little backward incompatibility issue. For example, if you had

<pre>
can :manage, User, :id => user.id
can :assign_roles, User do
  user.admin?
end
</pre>

and then you called @can? :assign_roles, user@ it evaluated to @false@, cause it stopped searching on @can :assign_roles, User@.
Now it evaluates to @true@ because it falls back to @can :manage, User, :id => user.id@ .

Proper can definition should be now:

<pre>
can :manage, User, :id => user.id
cannot :assign_roles, User
can :assign_roles, User if user.admin?
</pre>

And perhaps, good taste could be

<pre>
if user.admin?
  can :manage, User
else
  can :manage, User, :id => user.id
  cannot :assing_roles, User
end
</pre>

which is also backward compatible.