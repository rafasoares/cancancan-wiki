If [[Defining Abilities with Hashes]] is not flexible enough for your needs, it is possible to use a block. Here you can use any Ruby code to restrict what the user is able to access.

<pre>
can :update, Project do |project|
  project && project.groups.include?(user.group)
end
</pre>

If the block returns @true@ then the user has that @:update@ ability for that project, otherwise he will be denied access. It's possible for the passed in model to be @nil@ if one isn't specified, so be sure to take that into consideration.

*The downside to using a block is that it cannot be used when [[Fetching Records]].*

If @:all@ is passed then the class will be passed into the block along with the object (just in case the object is nil). Here the user has permission to read all objects except orders.

<pre>
can :read, :all do |object_class, object|
  object_class != Order
end
</pre>

If @:manage@ is used then the action is passed into the block as well. Here the user can do everything but destroy comments.

<pre>
can :manage, Comment do |action, comment|
  action != :destroy
end
</pre>

If you use both @:manage@ and @:all@ with a block you will have complete flexibility in how permissions are handled. See [[Abilities in Database]] for an example.